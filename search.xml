<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>matlab高级应用之plutosdr工具箱</title>
      <link href="/2022/03/24/matlab-gao-ji-ying-yong-zhi-plutosdr-gong-ju-xiang/"/>
      <url>/2022/03/24/matlab-gao-ji-ying-yong-zhi-plutosdr-gong-ju-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>matlab的魅力不仅在于其拥有着形形色色的内置函数，对于一些硬件平台，matlab也提供一些工具箱连接外部设备，达到一些高级仿真的目的。本文就介绍了如何利用matlab工具箱来设计一个FM信号发送与接收的系统模型。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>首先要准备一个plutosdr设备，还要在matlab中下载一个与pluto对应的工具包。<br><img src="https://static01.imgkr.com/temp/3e4f54c7fb5f45e18a6d66835f69b6e0.jpg"><br><img src="https://static01.imgkr.com/temp/1e22991008de49cebce55da6bcc31112.png"></p><h2 id="仿真过程"><a href="#仿真过程" class="headerlink" title="仿真过程"></a>仿真过程</h2><h3 id="simulink"><a href="#simulink" class="headerlink" title="simulink"></a>simulink</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在 SIMULINK 的发送模块，首先调整好元器件库中已有的 PLUTO 发送机，在发送机前，利用器件库中的抽取器和内插器，辅以低通滤波器来对原始信号的采样率进行无失真前提下的改变，以达到和 PLUTO 发送模块基带采样率尽量匹配的目的。然后通过延迟器（1&#x2F;(1-1&#x2F;z)）对信号进行近似的积分处理，积分后的信号和一个小数据常量分别作为相位偏移量和幅度形成新的信号，该信号经合理的增益以后，便可作为已调频信号经 PLUTO 发送机向外发送。<br>在 SIMULINK 的接收模块，调整元器件库中的 PLUTO 接收机，改变其中心频率使之与发送机的中心频率相等，以此保证正常通信。接收机将信号成功接收后，通过与发送模块完全相逆的过程，便可以将信号解调出来。</p><h4 id="发送模块整体电路图"><a href="#发送模块整体电路图" class="headerlink" title="发送模块整体电路图"></a>发送模块整体电路图</h4><p><img src="https://static01.imgkr.com/temp/bd2467ab7ee8481ca4597c8694162ce2.png"></p><h4 id="抗混叠滤波器及抽区内插"><a href="#抗混叠滤波器及抽区内插" class="headerlink" title="抗混叠滤波器及抽区内插"></a>抗混叠滤波器及抽区内插</h4><p><img src="https://static01.imgkr.com/temp/dde90ca60fcd4f85a1eb1979765e73b8.png"><br>为了减少计算机的运作量，将抽取与内插分为三个模块进行，其中滤波器的幅值响应如下：<br><img src="https://static01.imgkr.com/temp/0954d2bf50ac419faef7110716e5c1fa.png"><br>该低通滤波器的过渡带设置为15～24kHz，保证低频分量通过且与内插后的频率相适应，达到抗混叠的效果。<br>计算可得，通过抽取内插后，音频信号采样率由原始的48kHz变为400kHz。</p><h4 id="积分模块"><a href="#积分模块" class="headerlink" title="积分模块"></a>积分模块</h4><p><img src="https://static01.imgkr.com/temp/1f6bb10e7b5a4e4393788a147db78ce1.png"><br>为了测试通过延迟器所近似得到的积分模块的可行性，我们将一正弦信号输入此积分器，并连接两个数字示波器观察，其显示如下：<br><img src="https://static01.imgkr.com/temp/826d4674d06c47d7b98a9a9186f1867a.png"><br>可见积分器工作正常。</p><h4 id="调频模块"><a href="#调频模块" class="headerlink" title="调频模块"></a>调频模块</h4><p><img src="https://static01.imgkr.com/temp/2ea21e8db3f14d239e1a3f181f219270.png"><br>积分后的原始信号通过50的增益后作为相位偏移量，与常量幅度一起构成了新的信号，这个新的信号便为已调频信号。</p><h4 id="PLUTO发送机参数设置"><a href="#PLUTO发送机参数设置" class="headerlink" title="PLUTO发送机参数设置"></a>PLUTO发送机参数设置</h4><p><img src="https://static01.imgkr.com/temp/c998c47535894650b20b8be49210c2a6.png"><br>中心频率选取FM空白频道104MHz,基带采样率与输入信号匹配,由前知应该设为400kHz。</p><h4 id="接收模块整体电路图及参数设置"><a href="#接收模块整体电路图及参数设置" class="headerlink" title="接收模块整体电路图及参数设置"></a>接收模块整体电路图及参数设置</h4><p><img src="https://static01.imgkr.com/temp/1cbc28721f1d4c228138c9b240fe9721.png"><br><img src="https://static01.imgkr.com/temp/eaf3605fa2bd424ca1e19e2f6382ba3f.png"><br>中心频率应与发送机相匹配,设为 104MHz｡关于基带采样率,因为在同一台 PLUTO设备上,时钟源只有一个,其同时控制发送端与接收端,故基带采样率必须保持一致｡然而,为了方便在解调端前将信号及时地恢复为 48kHz 或其倍数的采样率,且考量到接收端基带采样率高于发送端时,收到的信号也能达到小失真解调的效果,我们借用另外一个 PLUTO 设备,接口换为 usb:1 并将基带采样率最终选择到2.4MHz｡<br>其他模块均与发送模块相逆，不再赘述。</p><h4 id="仿真测试"><a href="#仿真测试" class="headerlink" title="仿真测试"></a>仿真测试</h4><p>为了直观看出调制前和经PLUTO发送接收并解调后信号的变化，我们选取时域的模拟仿真观察。输入最简单的正弦信号，其前后时域波的对比如下：<br><img src="https://static01.imgkr.com/temp/1b31f0e11b604614a7ebf2dc0aae33d4.png"><br><img src="https://static01.imgkr.com/temp/eb999eaf0e5d43afb71c5af12dae95fc.png"><br>依次为输入与输出波形，可见有极大的失真。</p><h3 id="matlab代码设计（接收空间里的FM信号）"><a href="#matlab代码设计（接收空间里的FM信号）" class="headerlink" title="matlab代码设计（接收空间里的FM信号）"></a>matlab代码设计（接收空间里的FM信号）</h3><pre class="line-numbers language-none"><code class="language-none">fmRxParams.FrontEndFrameTime&#x3D;0.0168;fmRxParams.FrontEndSampleRate &#x3D;228e3; %取5倍音频采样率%初始化SDR接收端sigSrc&#x3D;comm.SDRRxPluto(...&#39;CenterFrequency&#39;,103e6,...%频道(Hz);&#39;GainSource&#39;,&#39;Manual&#39;,...&#39;Gain&#39;,50,...%音量增益&#39;ChannelMapping&#39;,1,...&#39;BasebandSampleRate&#39;,fmRxParams.FrontEndSampleRate,...&#39;OutputDataType&#39;,&#39;double&#39;,...&#39;SamplesPerFrame&#39;,4410);%初始化FM解调端fmBroadcastDemod &#x3D; comm.FMBroadcastDemodulator(...&#39;SampleRate&#39;, fmRxParams.FrontEndSampleRate,...&#39;FrequencyDeviation&#39;, 75e3,...&#39;FilterTimeConstant&#39;,7.5e-5,...&#39;AudioSampleRate&#39;, 45600,...&#39;Stereo&#39;,false);%初始化音频播放player &#x3D; audioDeviceWriter(&#39;SampleRate&#39; ,45600);%info( player)%初始化播放时间radioTime &#x3D; 0;totalLost &#x3D; 0;lost_frame &#x3D; single(zeros(4410, 1));m&#x3D;1;%%接收与播放if ~isempty(findPlutoRadio)%while radioTime &lt; userlnput.Duration %设置播放时间(秒)%while 1while radioTime&lt; 10%接收[rcv, lost, late] &#x3D; sigSrc();%rcv &#x3D; sigSrc();%lost &#x3D; 0;%late&#x3D;1.lost_frame(m)&#x3D;lost;m&#x3D;m+1;%解调FM广播信号并播放解码的音频audioSig &#x3D; fmBroadcastDemod(rcv);player(audioSig);%更新播放时间。添加可能丢失的样本帧时radioTime &#x3D; radioTime + fmRxParams.FrontEndFrameTime +... double(lost)&#x2F;fmRxParams.FrontEndSampleRate;totalLost &#x3D; totalLost + lost;endelsewarning(&#39;PlutoRadioNotFound&#39;) endfprintf(&#39;Total samples lost:%d(%d frames)\n&#39;,totalLost,int32(totalLost &#x2F; 4410*16)) [rx_signal,datavalid,overflow]&#x3D; sigSrc(); rt&#x3D; real(rx_signal(:,1)); t1&#x3D;(0: length(rt)-1).&#x2F;45600; st&#x3D; audioSig(:,1); t&#x3D;(0: length(st)-1).&#x2F;45600; Wn&#x3D; 8000 *2&#x2F;45600; [B, A]&#x3D; butter(8, Wn,&#39;low&#39;); yt&#x3D; filter(B, A, st);Nf &#x3D; length(st);Fs &#x3D; (0:Nf-1).&#x2F;Nf.*45600;RT &#x3D; fft(rt,Nf); %对FM信 号快速傅里叶变换ST&#x3D;fft(st,Nf);%对解调信号快速傅里叶变换YT&#x3D;fft(yt,Nf);%对恢复信号快速傅里叶变换figure(&#39;Position&#39;, [100, 200, 900, 500])subplot(321);%生 成FM信号的时域波形plot(t1(1:500), rt(1:500), &#39;linewidth&#39;, 1);%plot(t1, rt, ’linewidth’, 1);title(&#39;r(t):接收到的FM信号的时域波形&#39;);xlabel(&#39;t&#x2F;s&#39;);legend(&#39;r(t)&#39;); subplot(322);semilogy(Fs,abs(fftshift(RT))&#x2F;max(abs(RT)),&#39;linewidth&#39;,1,&#39;Color&#39;,&#39;g&#39;);title(&#39;r(t)-f:接收到的FM信号的频域波形&#39;); xlabel(&#39;f&#x2F;Hz&#39;);legend(&#39;R(f)&#39;); subplot(323); plot(t,st,&#39;linewidth&#39;,1);title(&#39;s(t):解调信号的时域波形&#39;); xlabel(&#39;t&#x2F;s&#39;);legend(&#39;s(t)&#39;);subplot(324);%生成解调信号的频域图形semilogy(Fs,abs(fftshift(ST))&#x2F;max(abs(ST)),&#39;linewidth&#39;,1,&#39;Color&#39;,&#39;g&#39;);title(&#39;s(t)_ f:解调信号的频域波形&#39;);xlabel(&#39;f&#x2F;Hz&#39;);legend(&#39;S(f)&#39;);subplot(325);%生成恢复信号的时域图形plot(t,yt,&#39;linewidth&#39;,1);title(&#39;y(t):恢复信号的时域波形&#39;);xlabel(&#39;t&#x2F;s&#39;);legend(&#39;y(t)&#39;);subplot(326);%生成恢复信号的频域图形semilogy(Fs,abs(fftshift(YT))&#x2F;max(abs(YT)),&#39;linewidth&#39;,1,&#39;Color&#39;,&#39;g&#39;);title(&#39;y(t)_ f:恢复信号的频域波形&#39;);xlabel(&#39;f&#x2F;Hz&#39;);legend(&#39;Y(f)&#39;);%%释放音频和信号源。并允许夏改其属性值和输入特性release(sigSrc)release(fmBroadcastDemod)release(player)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们开始收听几个频道的广播<br><img src="https://static01.imgkr.com/temp/a88b1c601eb34f2ca296e0751c9c555a.png"><br>央广经济之声（103MHZ）<br><img src="https://static01.imgkr.com/temp/051a3a1c2f53446bb58a66e59f513f1d.png"><br>央广音乐之声（95.5MHZ）</p><p>从时域上（只截取了很小部分）波形的平滑可见恢复后的信号噪声极低。<br>在频域上，收到的FM信号频率分量遍布整个范围内，解调后的信号突出了其中心频率为228kHz。经滤波器后的恢复信号，其中心频段两侧的带外分量也被滤除，噪声更加少，信号更加清晰。（其中，228kHz并不是该信号实际上的频率，是程序中解调端的采样速率，也是接收端的基带采样率。之所以中心突出在此，是在程序绘图中为了更加清晰地观察到频域上的变化而故意平移所致。）</p><h3 id="补充发送音频信号的代码"><a href="#补充发送音频信号的代码" class="headerlink" title="补充发送音频信号的代码"></a>补充发送音频信号的代码</h3><pre class="line-numbers language-none"><code class="language-none">%%发射初始化|txPluto &#x3D; sdrtx(&#39;Pluto&#39;,&#39;RadioID&#39;,&#39;usb:0&#39;,...&#39;CenterFrequency&#39;,92.4e6,...%频道(Hz);&#39;Gain&#39;,-0,...%音量增益&#39;ChannelMapping&#39;,1,...&#39;BasebandSampleRate&#39;,228000);txPluto.ShowAdvancedProperties &#x3D; true;afr&#x3D;dsp.AudioFileReader(&#39;gjhhh.flac&#39;,&#39;SamplesPerFrame&#39; ,44100&#x2F;2);%注意换成自己的音频adw &#x3D; audioDeviceWriter(&#39;SampleRate&#39;, afr.SampleRate);mod&#x3D;comm.FMBroadcastModulator(&#39;AudioSampleRate&#39;,afr.SampleRate,... &#39;SampleRate&#39; ,txPluto.BasebandSampleRate,&#39;Stereo&#39; ,false);%data&#x3D;audioread(&#39;Scarborough Fair.flac&#39;);sigSrc&#x3D;comm.SDRRxPluto(...&#39;CenterFrequency&#39;, 92.4e6,...%T he channel you want to listen to (Hz)&#39;GainSource&#39;, &#39;Manual&#39;,...&#39;Gain&#39;,50,...%can control volume&#39;ChannelMapping&#39;,1,...&#39;BasebandSampleRate&#39;,228000,...&#39;OutputDataType&#39;,&#39;single&#39;,...&#39;SamplesPerFrame&#39; ,45600*5&#x2F;2); %初始化解调fmBroadcastDemod &#x3D; comm.FMBroadcastDemodulator(...&#39;SampleRate&#39;, 228000, ...&#39;FrequencyDeviation&#39;, 75e3, ...&#39;FilterTimeConstant&#39;, 7.5e-5, ...&#39;AudioSampleRate&#39;, 45600, ...&#39;Stereo&#39; ,true);%创建音频播放器player &#x3D; audioDeviceWriter( &#39;SampleRate&#39; ,45600);while ~isDone(afr)data &#x3D; afr();%adw(data);data&#x3D;(data(:,1)+data(:,2))&#x2F;2;data&#x3D;mod(data);underflow&#x3D;txPluto(data);rcv &#x3D; sigSrc();audioSig &#x3D; fmBroadcastDemod(rcv);player(audioSig);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在框图实现时，由于在音频信号的带宽未知的情况下，经过抽取内插器前的抗混叠低通滤波器时可能会造成失真，并且在积分模块，积分器的组成本就是一个近似的过程，这些都使得接收解调后的信号会有失真现象，与扬声器连接后会听到噪声。并且这样的调频过程只能适用于一串数据，也就决定了其仅限于单声道音频的收发。<br>另外，在MATLAB代码模块，相对于SIMULINK完全手动设置的调频与解调过程，可由其自带的comm.FMBroadcast(De)Modulator这串结构体形式的代码实现，这样便消除了可能的失真问题。而其它的类似于sdrrx与sdrtx中Stereo这一变量的设置，便可以很方便的解决单声道与立体声收发的局限性。<br>代码模块的仿真模型，虽然可以小失真且多声道地收发音频，但是却无法直观看到信号调制与解调的原理以及详细过程。</p>]]></content>
      
      
      <categories>
          
          <category> matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab之仿真信号在高斯信道中的传播过程</title>
      <link href="/2022/03/21/matlab-zhi-sui-ji-xin-hao-fen-xi-duo-pin-lu-zheng-xian-xin-hao-die-jia-zao-sheng-tong-guo-di-tong-lu-bo-qi/"/>
      <url>/2022/03/21/matlab-zhi-sui-ji-xin-hao-fen-xi-duo-pin-lu-zheng-xian-xin-hao-die-jia-zao-sheng-tong-guo-di-tong-lu-bo-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>matlab的数据分析功能绝不仅仅是绘制一个图像以供直观分析那样简单，matlab自带的很多内置函数赋予了其在众多现代学科仿真中不可替代的作用。本文就利用了matlab中的一些有关“信号与系统”学科（比如傅里叶变换，滤波器产生等）的内置函数来分析仿真多音信号在实际信道传输后经过低通滤波器前后的时频域分析。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>为了尽可能趋近实际地仿真信号在信道中的传播过程，我们采用多音（多频率）正弦信号的叠加作为输入信号，信道可以通过叠加高斯白噪声来进行模拟，最后的低通滤波器便使用最为常见的巴特沃斯滤波器。这样的模拟过程在尽量模拟现实的前提下最大程度降低了仿真过程的实行复杂度。</li><li>线性系统（本过程中指代最终的巴特沃斯低通滤波器）包含叠加性和齐次性两个概念。<ul><li>叠加性指：当几个信号同时输入系统时，系统的响应等于系统对各个输入信号单独作用时响应的叠加，即若𝑥1 (𝑡) → 𝑦1 (𝑡) , 𝑥2 (𝑡) → 𝑦2 (𝑡)，则𝑥1 (𝑡) + 𝑥2 (𝑡) → 𝑦1 (𝑡) + 𝑦2(𝑡)。</li><li>齐次性指：系统的激励乘以非零常数 a 时，系统的响应也相应地乘以常数 a, 即若𝑥1 (𝑡) → 𝑦1 (𝑡)，则𝑎𝑥1 (𝑡) → 𝑎𝑦1 (𝑡)。</li><li>线性系统的重要性质还有积分性、微分性、频率保持性等。</li></ul></li><li>我们对模拟过程作出假设，最原始的声音信号为1khz的单音信号，其它频率的信号模拟由复用系统、信道噪声和人为等因素造成的干扰。因此，我们最终得到的信号应该是1khz的声音信号。</li></ul><h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><h3 id="滤波器产生（注意命名为lowpass，防止后期产生代码错误）"><a href="#滤波器产生（注意命名为lowpass，防止后期产生代码错误）" class="headerlink" title="滤波器产生（注意命名为lowpass，防止后期产生代码错误）"></a>滤波器产生（注意命名为lowpass，防止后期产生代码错误）</h3><pre class="line-numbers language-none"><code class="language-none">function Hd &#x3D; lowpass% 返回离散时间滤波器对象。Fs &#x3D; 5000000;  % 采样率N  &#x3D; 7;     % 阶数Fc &#x3D; 1000;  % 截止频率h  &#x3D; fdesign.lowpass(&#39;N,F3dB&#39;, N, Fc, Fs);Hd &#x3D; design(h, &#39;butter&#39;); %产生巴特沃斯滤波器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中用到了matlab自带的产生巴特沃斯滤波器的内置函数。</p><h3 id="信源与信道模拟"><a href="#信源与信道模拟" class="headerlink" title="信源与信道模拟"></a>信源与信道模拟</h3><pre class="line-numbers language-none"><code class="language-none">Caiyanglv &#x3D; 5e6;  %注意与滤波器采样率相同Caiyangdianshu &#x3D; 50000;dt &#x3D; 1&#x2F;Caiyanglv;Pinglv1 &#x3D; 1000;Pinglv2 &#x3D; 2000;Pinglv3 &#x3D; 3000;t &#x3D; 0:dt:dt*(Caiyangdianshu-1);SignalData0 &#x3D; sin(2*pi*Pinglv1*t);SignalData1 &#x3D; sin(2*pi*Pinglv2*t);SignalData2 &#x3D; sin(2*pi*Pinglv3*t);SignalData3 &#x3D; SignalData0+SignalData1+SignalData2;SignalData3 &#x3D; awgn(SignalData3,10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依然用到了matlab的内置awgn函数，help文档的介绍如下：<br><img src="https://static01.imgkr.com/temp/bd0c8cef0e174d22a03c3f8b411f62b6.png"><br>而我们采取了用法的第一种，被叠加的信号为signaldata3，信噪比（SNR）为10dB。</p><h3 id="输入信号分析"><a href="#输入信号分析" class="headerlink" title="输入信号分析"></a>输入信号分析</h3><pre class="line-numbers language-none"><code class="language-none">figure(1);plot(t*1000,SignalData3)title(&#39;输入信号时域波形&#39;)xlabel(&#39;时间&#x2F;ms&#39;);ylabel(&#39;幅度&#x2F;V&#39;);FFT_Data &#x3D; fft(SignalData3,Caiyangdianshu);Magnitude &#x3D; 2*sqrt(FFT_Data.*conj(FFT_Data));df &#x3D; 1&#x2F;dt&#x2F;Caiyangdianshu;f &#x3D; 0:df:(Caiyangdianshu-1)*df;figure(2);plot(f&#x2F;1000,Magnitude)title(&#39;输入信号频谱&#39;);xlabel(&#39;频率&#x2F;kHz&#39;);ylabel(&#39;幅值&#x2F;V&#39;);xlim([0,10]);[Rx,maxlags]&#x3D;xcorr(SignalData3,&#39;unbiased&#39;);figure(3);plot(maxlags&#x2F;Caiyanglv*1000,Rx&#x2F;max(Rx));title(&#39;输入信号自相关&#39;)xlabel(&#39;时延差&#x2F;ms&#39;);ylabel(&#39;R(τ)&#39;);ylim([-1,1]);gl&#x3D;abs(FFT_Data).^2; %功率谱figure(4);plot(f&#x2F;1000,gl);title(&#39;输入信号功率谱&#39;);xlabel(&#39;频率&#x2F;kHz&#39;);ylabel(&#39;W&#x2F;Hz&#39;);xlim([0,10]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相应的，关于fft（快速傅里叶变换）和xcoor（运算相关函数）的help文档介绍如下：<br><img src="https://static01.imgkr.com/temp/cb4f302ae0464f1fbfe59ccbc69689c6.png"><br><img src="https://static01.imgkr.com/temp/a7a06ac3c4b84ecdb1fc79dc999492a1.png"></p><h3 id="信号过低通巴特沃斯滤波器"><a href="#信号过低通巴特沃斯滤波器" class="headerlink" title="信号过低通巴特沃斯滤波器"></a>信号过低通巴特沃斯滤波器</h3><pre class="line-numbers language-none"><code class="language-none">SignalData4 &#x3D; filter(lowpass,SignalData3);figure(5);plot(t*1000,SignalData4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这里体现了之前滤波器文档命名的重要性。</p><h3 id="输出信号分析"><a href="#输出信号分析" class="headerlink" title="输出信号分析"></a>输出信号分析</h3><pre class="line-numbers language-none"><code class="language-none">title(&#39;输出信号时域波形&#39;)xlabel(&#39;时间&#x2F;ms&#39;);ylabel(&#39;幅度&#x2F;V&#39;);FFT_Data2 &#x3D; fft(SignalData4,Caiyangdianshu);Y &#x3D; 2*sqrt(FFT_Data2.*conj(FFT_Data2));figure(6);plot(f&#x2F;1000,Y)title(&#39;输出信号频谱&#39;);xlabel(&#39;频率&#x2F;kHz&#39;);ylabel(&#39;幅值&#x2F;V&#39;);xlim([0,10]);glo&#x3D;abs(FFT_Data2).^2; %功率谱figure(7);plot(f&#x2F;1000,glo);title(&#39;输出信号功率谱&#39;);xlabel(&#39;频率&#x2F;kHz&#39;);ylabel(&#39;W&#x2F;Hz&#39;);xlim([0,10]);[Rx,maxlags]&#x3D;xcorr(SignalData4,&#39;unbiased&#39;);figure(8);plot(maxlags&#x2F;Caiyanglv*1000,Rx&#x2F;max(Rx));title(&#39;输出信号自相关&#39;)xlabel(&#39;时延差&#x2F;ms&#39;);ylabel(&#39;R(τ)&#39;);ylim([-1,1]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h3><p><img src="https://static01.imgkr.com/temp/b386980d7f4442158be60586caf7cba2.png"><br><img src="https://static01.imgkr.com/temp/e595ad039b7743c994a25011e19dcd9b.png"><br><img src="https://static01.imgkr.com/temp/b8e12ef37298470f93619d3252b94daf.png"><br><img src="https://static01.imgkr.com/temp/11f517611cf14ef1934354227ec8f3e1.png"><br><img src="https://static01.imgkr.com/temp/7b99cd52e7404fa7b1ab0905892528d1.png"><br><img src="https://static01.imgkr.com/temp/df4dddd9a4f1498da8d601c639a4b75e.png"><br><img src="https://static01.imgkr.com/temp/26ee2825a5f04bbb80b53c0b9a6af28b.png"><br><img src="https://static01.imgkr.com/temp/25d55090cde24d0ebeadb2d898495816.png"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>从仿真结果中可以看出最终的输出信号其实是较为理想的，但是巴特沃斯滤波器的阶数选择是一个不可忽视的问题。当然，在仿真的过程中，我们可以任意选择阶数，只要能满足条件即可。但是实际电路中，阶数越高，导致的结果就是电路越复杂，越不容易实现。但是若又把结束选择过低，那么最终的滤波效果就不会很符合要求，比如下图就是阶数为3时的输出频谱图：<br><img src="https://static01.imgkr.com/temp/f4d5993972964bed8ea6ec2d96b3b59e.png"><br>可以看到干扰分量依旧很大。<br>所以，利用matlab仿真信号通过信道的过程，由于其大量的内置函数，使得该过程变得很简洁，这也是matlab的一大优点，但也应切实考虑实际电路的实现，这样才能得到反应工程现实的仿真结果。</p>]]></content>
      
      
      <categories>
          
          <category> matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab之基础绘图（行驻波）</title>
      <link href="/2022/03/21/matlab-zhi-ji-chu-hui-tu-xing-zhu-bo/"/>
      <url>/2022/03/21/matlab-zhi-ji-chu-hui-tu-xing-zhu-bo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MATLAB是matrix和laboratory两个词的组合，意为矩阵工厂或者矩阵实验室，是一种著名的商业数学软件，可用于数据分析、无线通信、深度学习、图像处理与计算机视觉、信号处理、量化金融与风险管理、机器人，控制系统等领域。本文就简单地介绍了利用matlab进行数据处理，主要关注数据之间的关系与二维图形的绘制。</p><h2 id="绘图介绍与举例分析"><a href="#绘图介绍与举例分析" class="headerlink" title="绘图介绍与举例分析"></a>绘图介绍与举例分析</h2><h3 id="绘图函数介绍"><a href="#绘图函数介绍" class="headerlink" title="绘图函数介绍"></a>绘图函数介绍</h3><p>matlab中带有形形色色的绘图函数，常见的有plot、mesh、surf、hist等，它们分别代表绘制二位线图、网格曲面图、曲面图和直方图。plot函数一般就可以解决普通的数值分析问题或者高级的信号处理问题，而后三者常用于高级的统计学或者数据分析中，因此我们重点关注plot函数的用法规则。<br>matlab命令行输入<code>help plot</code>就可以得到官方对于plot的解释。<br><img src="https://static01.imgkr.com/temp/e5e24ea64622468fb5f64db0a5f19eb1.png"><br>图中可见，第一大段文字为对本函数的基本介绍，后面的几行是其常见的运用规则（语法），我们可以从中得到下面几种注意事项：</p><ul><li>绘图时，横坐标数据（X）和纵坐标数据（Y）必须一致（不然怎么一一对应呢）</li><li>当绘图数据为离散数据时，plot也会绘制出连续图。</li></ul><h3 id="plot函数的常见搭配"><a href="#plot函数的常见搭配" class="headerlink" title="plot函数的常见搭配"></a>plot函数的常见搭配</h3><p>在matlab的help文档中，对于plot函数还引申了它的常用搭配。其中title表示对绘制出的图形命名，xlabel表示对X轴变量命名，ylabel表示对Y轴变量命名，xlim表示对X轴所代表的数据取有用区间，ylim表示对Y轴所代表的数据取有用区间。</p><h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h3><h4 id="普通三角函数"><a href="#普通三角函数" class="headerlink" title="普通三角函数"></a>普通三角函数</h4><p>代码</p><pre class="line-numbers language-none"><code class="language-none">x&#x3D;0:pi&#x2F;100:2*pi; %X取值从0到2Π，取值间隔为Π&#x2F;100y&#x3D;sin(x); %函数关系plot(x,y); %绘图title(&quot;sin函数图像&quot;); %图像命名xlabel(&quot;x&quot;); %X轴命名（标注）ylabel(&quot;y&quot;); %Y轴命名（标注）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下<br><img src="https://static01.imgkr.com/temp/9fd6562201e24037ba17dc6c701668b5.png"></p><h4 id="行驻波绘图"><a href="#行驻波绘图" class="headerlink" title="行驻波绘图"></a>行驻波绘图</h4><p>行波与驻波是在大学学习中常见的几个概念，无论是物理，或者深入的电磁波、微波、雷达等学科中也常常使用。<br>在介绍行驻波绘图前，我们首先拓展一下关于plot函数的用法，当代码中出现subplot这种函数字样时，表明将几张图像同时绘制到一张图上显示。比如<code>subplot(2,2,1)</code>表示一张2行2列的图像集合，而本图像绘制在第1个位置。</p><pre class="line-numbers language-none"><code class="language-none">z&#x3D;0:0.1:8*pi; %Z的取值由0到Π，间隔为0.1for t&#x3D;1:5000  %时间上取值，也表明循环次数    u&#x3D;cos(0.05*t-z) %行波表达式    subplot(2,1,1)     plot(u) %行波绘图，绘制在第一个    title(&quot;行波&quot;)    ylim([-1 1]) %绘图标注    i&#x3D;sin(z)*cos(0.05*t) %驻波表达式    subplot(2,1,2)     plot(i) %驻波绘图，绘制在第一个    title(&quot;驻波&quot;)    ylim([-1 1]) %绘图标注    pause(0.001) %时间暂停，以此显示变化的函数的动态过程end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终结果如下<br><img src="https://static01.imgkr.com/temp/9b08e46c5872438c8fecac82da10646f.png"><br><img src="https://static01.imgkr.com/temp/384eca5c1c994d2c9a7d87435576e129.png"><br><img src="https://static01.imgkr.com/temp/c1de21c64f9842638ff14680b767805a.png"><br><img src="https://static01.imgkr.com/temp/48986f5b382640b89cea49612399fbf8.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从以上的具体代码看，matlab并不像C语言那样有过于严格的函数体或者格式要求，并且有非常多的内置函数，这在使用时非常方便。而且，matlab的众多工具箱使得其在很多复杂的学科仿真上有重大运用。</p>]]></content>
      
      
      <categories>
          
          <category> matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之利用随机数据计算圆周率</title>
      <link href="/2022/03/20/python-zhi-li-yong-sui-ji-shu-ju-ji-suan-yuan-zhou-lu/"/>
      <url>/2022/03/20/python-zhi-li-yong-sui-ji-shu-ju-ji-suan-yuan-zhou-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>π (圆周率)是数学和物理学普遍存在的常数之一,它定义了一个标准圆周长与直径之比。众所周知，圆周率是一个无理数，即无限不循环小数。精确求解圆周率是几何学、物理学和很多工程学科的关键。<br>对π的精确求解曾经是数学历史上直难以解决的问题之 ，因为π无法用任可精确公式表示，在电子计算机出现以前，π只能通过一些近似公式的求解得到，直到1948年，人类才以人工计算方式得到π的808位精确小数。<br>随着计算机的出现，数学家找到了求解π的另类方法:蒙特卡罗(Monte Carto)方法，又称随机抽样或统计试验方法。该方法属于计算数学的一个分支， 由于其能够真实地模拟实际物理过程，因此，解决问题与实际非常符合，可以得到很圆满的结果。蒙特卡罗方法广泛应用于数学、物理学和工程领域。<br>当所要求解的问题是某种事件出现的概率，或者是某个随机交量的期望值时，它们可以通过某种“试验”的方法，得到这种事件出现的频率，或者这个随机变数的平均值，并用它们作为问题的解。这是蒙特卡罗方法的基本思想。</p><h2 id="蒙特卡罗法简介"><a href="#蒙特卡罗法简介" class="headerlink" title="蒙特卡罗法简介"></a>蒙特卡罗法简介</h2><p>应用蒙特卡罗方法求解π的基本步骤如下:随机向如下图所示的单位正方形和圆结构，抛酒大量“飞镖”点，计算每个点到圆心的距离从而判断该点在圆内或者圆外，用圆内的点数除以总点数就是π&#x2F;4值。随机点数量越大，越充分覆盖整个图形，计算得到的π值越精确。实际上，这个方法的思想是利用离散点值表示图形的面积，通过面积比例来求解π值。<br><img src="https://static01.imgkr.com/temp/0deae0b1ed7e4cb684ed3867b9d22bef.jpg"><br>为了简化计算，一般利用图形的1&#x2F;4来求解，如下图<br><img src="https://static01.imgkr.com/temp/fb58982173434f9cb6a3fc2f3fc07432.jpg"></p><h2 id="python求解"><a href="#python求解" class="headerlink" title="python求解"></a>python求解</h2><p>程序如下</p><pre class="line-numbers language-none"><code class="language-none">from random import random #引入random库from math import sqrt #引入平方根函数from time import perf_counter #引入计时函数DARTS&#x3D;1000 #拟定抛点数，多多益善，但过多会极大延长程序运行时间hits&#x3D;0.0perf_counter() #计时for i in range(1,DARTS+1):    x,y&#x3D;random(),random() #生成随机坐标    dist&#x3D;sqrt(x**2+y**2) #计算坐标离原点的距离    if dist &lt;&#x3D;1.0:        hits&#x3D;hits+1  #圆心内的计数pi&#x3D;4*(hits&#x2F;DARTS)print(&quot;PI值是&#123;&#125;。&quot;.format(pi))print(&quot;&#123;:.5f&#125;s&quot;.format(perf_counter()))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如图：<br><img src="https://static01.imgkr.com/temp/277c6926a93d45b6bb7edc99f9b65052.png"><br>从上至下以此为抛点数为1000、10000、2^15、2^20，可见随着抛点数增加，计算结果趋近于准确值，但运行时间也越来越长。当抛点数达到2^25时，计算结果仍为3.141左右，但是运行时间却高达35-60s。这样的程序明显是耗费时间且没必要的，故应该慎重选择抛点数。</p><h2 id="结束语（感悟）"><a href="#结束语（感悟）" class="headerlink" title="结束语（感悟）"></a>结束语（感悟）</h2><p>计算圆周率的这个程序，是我在一本自学python的教程中学到的，然而当时却遇到了很多问题，最大的问题莫过于计时函数无法运行，书中介绍的计时函数表达为<code>clock()</code>，可当我正式运行的时候，却总是卡在这一步，后来翻找了很多关于python计时函数的介绍，在一篇介绍计时函数发展史中找到了答案。<br>原来在最新的版本中，<code>clock()</code>已被<code>perf_counter()</code>替代。修改之后的程序在最新版本中的python才可以运行成功。<br>所以，作为一个在校学习的大学生，现有的课本知识确实很经典，但是一些新兴的专业知识或者技术也在悄然发展，而这些便需要我们阅读课外读物，上手实践才能逐步掌握。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建及初始化</title>
      <link href="/2022/03/19/hexo-bo-ke-da-jian-ji-chu-shi-hua/"/>
      <url>/2022/03/19/hexo-bo-ke-da-jian-ji-chu-shi-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文介绍了hexo博客的搭建，也就是本网站的制作过程。hexo博客凭借着github平台，不用像其它服务器那样付月租费用，这一点对于我们学生来说非常友好。所以，我们应该先在github官网（直接网上搜）上面申请一个账号，然后借用此账号给我们的博客网站提供服务器支持。 </p><h2 id="下载git"><a href="#下载git" class="headerlink" title="下载git"></a>下载git</h2><p>git可以直接在该网址上下载<a href="https://git-scm.com/">https://git-scm.com/</a><br>进入网页后直接找到download按钮即可。<br><img src="https://static01.imgkr.com/temp/4c873c868775449fab930e6390e6c559.png"><br><img src="https://static01.imgkr.com/temp/9737f337ea1843fa9362f85645201833.png"><br>关于下载过程，可以参考此网站。<a href="https://www.cnblogs.com/ximiaomiao/p/7140456.html">https://www.cnblogs.com/ximiaomiao/p/7140456.html</a></p><h2 id="下载node"><a href="#下载node" class="headerlink" title="下载node"></a>下载node</h2><p>下载地址：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a><br><img src="https://static01.imgkr.com/temp/d8f824671c194278b3cb85b6524d6104.png"><br>界面里会有LTS和CURRENT两个版本，不需要下载最新的，只需要下载LTS版本即可。<br>至于下载过程，只需要一直点击下一步即可。</p><h2 id="安装hexo-此过程后都是在git中运行）"><a href="#安装hexo-此过程后都是在git中运行）" class="headerlink" title="安装hexo (此过程后都是在git中运行）"></a>安装hexo (此过程后都是在git中运行）</h2><p>首先点击桌面右键，选择git bash here，即可打开git。<br>在git中，我们输入以下代码：</p><pre class="line-numbers language-none"><code class="language-none">node -vnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述两行代码后缀-v表示检测本机已有应用的版本号。<br>接下来，我们需要下载淘宝镜像源。</p><pre class="line-numbers language-none"><code class="language-none">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.orgcnpmcnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上三行分别表示下载镜像源，检测是否下载成功，返回镜像源版本信息。<br>之后就开始正式下载hexo了，依旧在git上输入以下代码：</p><pre class="line-numbers language-none"><code class="language-none">cnpm install -g hexo-clihexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以上两行依然表示下载与检测版本信息</p><h2 id="初始化博客（开始进入正题了）"><a href="#初始化博客（开始进入正题了）" class="headerlink" title="初始化博客（开始进入正题了）"></a>初始化博客（开始进入正题了）</h2><p>在本地建立一个blog文件夹，进入该文件夹内，以后的所有git操作都在blog文件下进行。<br>输入以下代码：</p><pre class="line-numbers language-none"><code class="language-none">hexo initls -lhexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述三行分别表示初始化hexo，查看初始化获得的文件，启动hexo。<br>hexo s 命令出现后，会产生一个临时网址，localhost:4000，这样就可以在本地4000端口查看自己的网站了。</p><h2 id="将网站部署到github上"><a href="#将网站部署到github上" class="headerlink" title="将网站部署到github上"></a>将网站部署到github上</h2><p>首先申请一个自己的github账号（见前言），然后我们在github上按照“自己的昵称+github.io建立一个自己的仓库，也就是repository（这个建立方法在一进入github主界面就可以看到），比如jiahao-g.github.io<br>之后我们就回到blog文件夹下的git页面，输入代码（安装hexo插件）：</p><pre class="line-numbers language-none"><code class="language-none">cnpm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后找到blog文件下的-config.yml文件，用编辑器打开（推荐vscode,据说比较方便，但是我用的是matlab,这个相信每个工科生都必备的），找到以下代码<br><img src="https://static01.imgkr.com/temp/6aead5e511ff42508534084978f54aec.png"><br>我的这里是已经修改好了的，原始代码可以按照这里的不同进行修改，注意repo后面的部分要改成自己的仓库。编辑后记得保存。<br>之后在git中输入<code>hexo d</code>就可以将本地文件部署到github上了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>其实hexo博客的搭建远没有上述初始化那么简单，只不过像之后的主题更改或者博客书写都具有强烈的个人色彩，一个人一种方式，利用<code>git clone</code>命令之后就可以下载复制一个具有自己个性的主题，而之后的所有修改都将依照主题的官网而定。<br>本博客使用的是matery主题，对于初学者来讲，yilia主题更容易操控，复制网址为：<br><a href="http://github.com/litten/hexo-theme-yilia.git">http://github.com/litten/hexo-theme-yilia.git</a><br>其修改方式网上有很多，也很杂，本文不再叙述（根据自己的个性而定）<br>最后，希望大家都能如愿成功搭建一个拥有自己个性的博客网站。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makedown文件的编写规范</title>
      <link href="/2022/03/19/makedown-wen-jian-de-bian-xie-gui-fan/"/>
      <url>/2022/03/19/makedown-wen-jian-de-bian-xie-gui-fan/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>关于makedown，百度上的介绍如下：</p><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。</p><p>hexo博客的编写便是使用了makedown语言，产生的文件的后缀符为.md。本文简单地介绍了makedown语法编写博客文章的一些具体语法。</p><h2 id="基础语法介绍"><a href="#基础语法介绍" class="headerlink" title="基础语法介绍"></a>基础语法介绍</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>在想要设置为标题的文字前方加#（注意#和文字中间空一格）。#个数越多意味着标题级数越高，一级标题便是一个#号，二三…级标题以此类推。makedown共支持6级标题。</p><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>段落的编写极其简单，只需要每段内容前后空出一行即可。</p><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>当作者写文章时想要对某些内容进行强调显示时，makedown使用特殊符号” &gt; “（同样的，和具体内容之间需要空一格），下面就举一个例子，效果如下：</p><blockquote><p>这是引用段落，会被高亮显示</p></blockquote><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>超链接的书写规范包括两部分，首先是一个中括号【】，注意要用英文中的中括号，括号里显示文章中要显示的超链接文字，之后紧挨着小括号()，小括号里面是要打开的网址。下面举个百度主页的例子：<br><a href="https://www.baidu.com/?tn=80035161_1_dg">百度</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图片的插入法与超链接相比，仅在超链接的表达方法前面加一个感叹号，不再举例子赘述。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表在文字前方加一星号（由于直接打出符号会被识别成斜体内容，故之后都用汉字表示星号，其实，+、-都可以，但是星号最常用，比如举例如下：</p><ul><li>无序列表项</li><li>无序列表项</li><li>无序列表项</li></ul><p>同时，makedown也支持无序列表的嵌套，但是下一级的嵌套需要空格，最好是空三格，举例如下：</p><ul><li>无序列表项<ul><li>第二级无序列表项</li><li>第二级无序列表项</li></ul></li><li>无序列表项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表与无序列表基本相同，只需要把星号换成数字加点（如：1.），举例如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><p>同时，有序列表项也可以嵌套，语法与有序列表相同。</p><ol><li>有序列表项1<ol><li>有序列表项11</li><li>有序列表项12</li></ol></li><li>有序列表项3</li></ol><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线可以用连续的三个*或者三个-表述，不再赘述。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>字体除了正常的之外，其它常见的有粗体及斜体。斜体使用星号开启，然后跟着文字内容，最后也是星号结束；粗体和斜体类似，只不过用两个星号开启和结束。下面举例：<br><em>这里是斜体内容</em><br><strong>这里是粗体内容</strong></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>行内代码：使用单个反引号进行包裹行内代码；<br>多行代码：可以通过三个反引号将代码包裹起来，反引号单独占一行，多一行单引号后面可以需要添加编程语言，例如：</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123; printf(&quot;&quot;)return 0&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>由于博客文章本就是用makedown来编写的，在后台的代码也会自动识别成相应的效果显示，所以无法在文章中具体到代码和效果的对比。希望读者能在有限的文字中了解到书写规范。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书写博客主要代码介绍</title>
      <link href="/2022/03/07/hello-world/"/>
      <url>/2022/03/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
